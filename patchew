#!/usr/bin/env python2
#
# The MIT License (MIT)
#
# Copyright (c) 2014 Fam Zheng <fam@euphon.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import sys
import os
import argparse
import email
import mailbox
import json
import shutil
import hmac
import urllib
import tempfile
import time
import subprocess
import libpatchew
from libpatchew import *

def dump_headers(m):
    print "  From:", m.get_from(True)
    print "  To:", m.get_to(True)
    print "  Cc:", m.get_cc(True)

def dump_status(db, msg_id):
    def prettify(k, v):
        if k in ["reviewers", "repliers"]:
            return ", ".join("%s <%s>" % (n, a) for n, a in v)
        return v

    s = db.get_statuses(msg_id)
    for k, v in s.iteritems():
        print "  %-20s = %s" % (k, prettify(k, v))

def import_message(db, m, verbose):
    msg = Message(m.as_string())
    r = None
    try:
        r = db.add_message(msg)
        if verbose:
            print "Message:", msg.get_subject()
    except MessageDuplicated:
        if verbose:
            print "Message duplicated:", msg.get_message_id(), msg.get_subject()
    except Exception, e:
        print "Error while saving message:"
        print m.as_string()
        raise
    return r

def import_mbox(db, f, verbose):
    r = []
    mbox = mailbox.mbox(f)
    for m in mbox:
        i = import_message(db, m, verbose)
        if i:
            r.append(i)
    return r

def import_mail(db, f, verbose):
    m = email.message_from_file(open(f, 'r'))
    if m:
        return import_message(db, m, verbose)

def import_args(parser):
    parser.add_argument("file", nargs="+", help="The file(s) to import")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Show more information")
    parser.add_argument("-r", "--reset", action="store_true",
                        help="Reset the DB before import")

def is_mbox_file(f):
    fd = open(f, 'r')
    l = ""
    while not l.strip():
        l = fd.readline()
    return l.startswith("From ")

def import_cmd(db, args):
    if args.reset:
        db.reset()
    a = []

    def import_one(a, f):
        if is_mbox_file(f):
            a += import_mbox(db, f, args.verbose)
        else:
            m = import_mail(db, f, args.verbose)
            if m:
                a.append(m)

    def walk_dir(a, dirname, fnames):
        for i in fnames:
            import_one(a, os.path.join(dirname, i))

    for f in args.file:
        if os.path.isdir(f):
            os.path.walk(f, walk_dir, a)
        else:
            import_one(a, f)
    for i in a:
        db.process_message(i)

def syncdb_args(parser):
    parser.add_argument("-m", "--message-id", type=str, default="",
                        help="Only process the message with given message-id")

def syncdb_cmd(db, args):
    if not args.message_id:
        for s in db.find_messages():
            db.process_message(s.get_message_id())
    else:
        db.process_message(args.message_id)
    return True

def add_query_args(parser):
    parser.add_argument("query", type=str, default="", nargs="*",
                        help="Query string")

def query_args(parser):
    parser.add_argument("-r", "--reverse", action="store_true",
                        help="Sort reversely")
    parser.add_argument("-p", "--patches", action="store_true",
                        help="Show patches in the series")
    parser.add_argument("-n", "--limit", type=int, default=0,
                        help="Limit the number of output")
    parser.add_argument("-f", "--format", type=str, default="oneline",
                        help="""Format of the patch.
    oneline - one line for each series
    short - one line for each message
    medium - one line for each message, plus some meta info
    mbox - mbox format of the whole series
    patches - mbox format of the patches in this series (not including cover
              letter)
    id - the message id""")
    add_query_args(parser)

def query_cmd(db, args):
    c = 0
    fmt = args.format
    for s in db.find_series(" ".join(args.query), args.reverse):
        if fmt == "oneline":
            print s.get_date(), "", s
        elif fmt == "verbose":
            dump_headers(s)
            dump_status(db, s.get_message_id())
            print
        elif fmt == "short":
            print s.get_date(), "", s
            for p in db.get_patches(s):
                if p.get_message_id() != s.get_message_id():
                    print "                    ", p
            print
        elif fmt == "medium":
            print s.get_date(), "", s
            for p in db.get_patches(s):
                if p.get_message_id() != s.get_message_id():
                    print "                    ", p
            for k, v in db.get_statuses(s.get_message_id()).iteritems():
                print "%16s: %s" % (k, v)
            print
        elif fmt in ["patches", "mbox"]:
            if fmt == "mbox":
                print s.mbox()
            for p in db.get_patches(s):
                print p.mbox()
            print
        elif fmt == "id":
            print s.get_message_id()
        else:
            print "Unrecognized format:", fmt
        c += 1
        if args.limit and c == args.limit:
            break
    return 0

def untest_args(parser):
    add_query_args(parser)

def untest_cmd(db, args):
    for s in db.find_series(" ".join(args.query)):
        st = db.get_status(s.get_message_id(), "testing")
        if st:
            print "untest:", s.get_subject()
            db.set_status(s.get_message_id(), "testing", None)

def delete_args(parser):
    add_query_args(parser)

def delete_cmd(db, args):
    for s in db.find_series(" ".join(args.query)):
        print "Delete:", s.get_subject()
        db.delete_series(s)

def set_status_args(parser):
    parser.add_argument("-i", "--id", required=True,
                        help="Message id of the series")
    parser.add_argument("name", type=str,
                        help="Status name")
    parser.add_argument("value", type=str, default="",
                        help="Status value, default is empty")

def set_status_cmd(db, args):
    s = db.get_series(args.id)
    if not s:
        print "Cannot find message with id:", args.id
        return 1
    db.set_status(args.id, args.name, args.value)

def get_status_args(parser):
    parser.add_argument("-i", "--id", required=True,
                        help="Message id of the series")
    parser.add_argument("name", type=str,
                        help="Status name")

def get_status_cmd(db, args):
    s = db.get_series(args.id)
    if not s:
        print "Cannot find message with id:", args.id
        return 1
    r = db.get_status(args.id, args.name)
    if r:
        print r

def server_args(parser):
    parser.add_argument("-c", "--config", help="Config file")
    parser.add_argument("-p", "--port", type=int, help="Override port number")
    parser.add_argument("-d", "--debug", action="store_true", help="Override debug flag")

def server_cmd(db, args):
    if not libpatchew.config.load_config(args.config,
                              "server.conf",
                              "/etc/patchew/server.conf"):
        print "Cannot find config file"
    host = libpatchew.config.get("server", "host", "0.0.0.0")
    port = libpatchew.config.get("server", "port", 80)
    debug = libpatchew.config.get("server", "debug", False)
    if args.port:
        port = int(args.port)
    start_server(db, host=host, port=port, debug=debug)
    return 0

def newid_args(parser):
    parser.add_argument("identity")

def newid_cmd(db, args):
    hasher = hmac.new(str(time.time()), args.identity)
    key = hasher.hexdigest()
    db.save_identity_pair(args.identity, key)
    print key

commands = {
    'import':  {
        'args': import_args,
        'cmd': import_cmd,
    },
    'syncdb':  {
        'args': syncdb_args,
        'cmd': syncdb_cmd,
        'help': 'rescan all the messages and update metadata',
    },
    'query':  {
        'args': query_args,
        'cmd': query_cmd,
    },
    'untest':  {
        'args': untest_args,
        'cmd': untest_cmd,
        'help': 'reset testing date for series',
    },
    'delete':  {
        'args': delete_args,
        'cmd': delete_cmd,
        'help': 'delete series by query',
    },
    'set-status':  {
        'args': set_status_args,
        'cmd': set_status_cmd,
        'help': 'set status of series',
    },
    'get-status':  {
        'args': get_status_args,
        'cmd': get_status_cmd,
        'help': 'get status of series',
    },
    'server':  {
        'cmd': server_cmd,
        'args': server_args,
    },
    'newid': {
        'cmd': newid_cmd,
        'args': newid_args,
    },
}

def create_db(url):
    dbt, rest = url.split("://", 2)
    if dbt != "mongo":
        raise Exception("Unknown database type: " + dbt)
    if "/" not in rest:
        raise Exception("Missing database name")
    server, dbname = rest.split("/")
    if ":" in server:
        server, port = server.split(":", 2)
        try:
            port = int(port)
        except Exception, e:
            raise Exception("Invalid port: " + port)
    else:
        port = None
    return DB(server, port, dbname)

def no_db_wrap(fn):
    def wrap(db, args):
        return fn(args)
    return wrap

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-d", "--db", type=str, default="mongo://localhost/patchew",
                        help="database url: <type>://<server>[:<port>]/<dbname>\nCurrently only mongo:// is supported")
    subparsers = parser.add_subparsers(title="subcommands")
    for c, v in commands.iteritems():
        p = subparsers.add_parser(c, help=v.get("help"))
        if 'args' in v:
            v['args'](p)
        if v.get('require-db', True):
            p.set_defaults(func=v['cmd'])
            p.set_defaults(require_db=True)
        else:
            p.set_defaults(func=no_db_wrap(v['cmd']))
            p.set_defaults(require_db=False)
    args = parser.parse_args()

    db = None
    if args.require_db:
        try:
            db = create_db(args.db)
        except Exception, e:
            print "Error in initializing database:", e
            return -1
    return args.func(db, args)

if __name__ == '__main__':
    sys.exit(main())

