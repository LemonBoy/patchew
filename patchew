#!/usr/bin/env python2
#
# The MIT License (MIT)
#
# Copyright (c) 2014 Fam Zheng <famcool@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import sys
import os
import shutil
import argparse
import time
import email
import mailbox
import subprocess
import tempfile
import urllib
import json
from libpatchew import *

VERSION = 1

def dump_headers(m):
    print "  From:", m.get_from(True)
    print "  To:", m.get_to(True)
    print "  Cc:", m.get_cc(True)

def dump_status(db, msg_id):
    def prettify(k, v):
        if k in ["reviewers", "repliers"]:
            return ", ".join("%s <%s>" % (n, a) for n, a in v)
        return v

    s = db.get_statuses(msg_id)
    for k, v in s.iteritems():
        print "  %-20s = %s" % (k, prettify(k, v))

def import_message(db, m, verbose):
    msg = Message(m.as_string())
    r = None
    try:
        r = db.add_message(msg)
        if verbose:
            print "Message:", msg.get_subject()
    except MessageDuplicated:
        print "Message duplicated:", msg.get_message_id(), msg.get_subject()
    except Exception, e:
        print "Error while saving message:"
        print m.as_string()
        raise
    return r

def import_mbox(db, f, verbose):
    r = []
    mbox = mailbox.mbox(f)
    for m in mbox:
        i = import_message(db, m, verbose)
        if i:
            r.append(i)
    return r

def import_mail(db, f, verbose):
    m = email.message_from_file(open(f, 'r'))
    if m:
        return import_message(db, m, verbose)

def import_args(parser):
    parser.add_argument("file", nargs="+", help="The file(s) to import")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Show more information")
    parser.add_argument("-r", "--reset", action="store_true",
                        help="Reset the DB before import")

def is_mbox_file(f):
    fd = open(f, 'r')
    l = ""
    while not l.strip():
        l = fd.readline()
    return l.startswith("From ")

def import_cmd(db, args):
    if args.reset:
        db.reset()
    a = []

    def import_one(a, f):
        if is_mbox_file(f):
            a += import_mbox(db, f, args.verbose)
        else:
            m = import_mail(db, f, args.verbose)
            if m:
                a.append(m)

    def walk_dir(a, dirname, fnames):
        for i in fnames:
            import_one(a, os.path.join(dirname, i))

    for f in args.file:
        if os.path.isdir(f):
            os.path.walk(f, walk_dir, a)
        else:
            import_one(a, f)
    for i in a:
        db.process_message(i)

def syncdb_args(parser):
    parser.add_argument("-m", "--message-id", type=str, default="",
                        help="Only process the message with given message-id")

def syncdb_cmd(db, args):
    if not args.message_id:
        for s in db.find_messages():
            db.process_message(s.get_message_id())
    else:
        db.process_message(args.message_id)
    return True

def add_query_args(parser):
    parser.add_argument("query", type=str, default="", nargs="*",
                        help="Query string")

def query_args(parser):
    parser.add_argument("-r", "--reverse", action="store_true",
                        help="Sort reversely")
    parser.add_argument("-p", "--patches", action="store_true",
                        help="Show patches in the series")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Show more information about series")
    add_query_args(parser)

def query_cmd(db, args):
    for s in db.find_series(" ".join(args.query), args.reverse):
        print s.get_date(), "", s
        if args.verbose:
            dump_headers(s)
            dump_status(db, s.get_message_id())
            print

        if args.patches:
            for p in db.get_patches(s):
                if p.get_message_id() != s.get_message_id():
                    print "                    ", p
            print
    return 0

def untest_args(parser):
    add_query_args(parser)

def untest_cmd(db, args):
    for s in db.find_series(" ".join(args.query), args.reverse):
        st = db.get_status(s.get_message_id(), "testing")
        if st:
            db.set_status(s.get_message_id(), "testing", None)


def server_cmd(db, args):
    start_server(db, host='0.0.0.0', debug=True, port=8080)
    return 0

def tester_args(parser):
    parser.add_argument("-s", "--server", required=True,
                        help="Pathew server's base URL")
    parser.add_argument("-t", "--test-script", required=True,
                        help="Test script to run inside the container")
    parser.add_argument("-i", "--image", required=True,
                        help="Docker image to use.")
    parser.add_argument("-L", "--loop", action="store_true",
                        help="Loop and repeat.")
    parser.add_argument("-C", "--quick-repo",
                        help="""Clone from a (faster) git repo before pulling
                        from the server returned codebase, in order to speed up
                        the test.""")
    parser.add_argument("-k", "--keep-temp", default=False, action="store_true",
                        help="Don't remove temporary directory before exit")

class CallException(Exception):
    pass

logf = None
def test_log(*w):
    m =  "".join([str(x) for x in w])
    if logf:
        logf.write(m)
    sys.stdout.write(m)

def check_call(args, echo=False, quiet=True, **kwargs):
    def escape(x):
        if " " in x and '"' in x:
            return '"%s"' % x.replace('"', '\\"')
        return x
    if echo:
        test_log(" ".join([escape(x) for x in args]) + "\n")
    err = tempfile.TemporaryFile()
    try:
        devnull = open("/dev/null", "w")
        if quiet:
            kwargs["stdin"] = devnull
            kwargs["stdout"] = devnull
        kwargs["stderr"] = err
        return subprocess.check_call(args, **kwargs)
    except Exception, e:
        test_log("Failed to run command: \n%s\n" % ' '.join([escape(x) for x in args]))
        err.seek(0)
        test_log(err.read(), "\n")
        raise
    finally:
        err.close()
        devnull.close()

def git(args, **kwargs):
    return check_call(["git"] + args, echo=True, **kwargs)

def dump_test_spec(spec):
    for k_, v in spec.iteritems():
        k = "%-30s :" % k_
        if isinstance(v, list):
            test_log(k, "[...]\n")
        elif "\n" in str(v):
            test_log(k)
            test_log(v, "\n")
        else:
            test_log(k, v, "\n")

def init_git_repo(spec, clone, repo):
    """ Do git clone, add remote, fetch and checkout """
    git(["clone", clone, repo])
    git(["remote", "add", "patchew-base", spec['codebase']], cwd=repo)
    git(["fetch", "patchew-base"], cwd=repo)
    git(["clean", "-dfx"], cwd=repo)
    git(["checkout", "-f", "remotes/patchew-base/%s" % spec['branch']], cwd=repo)

def write_patches(spec, odir):
    def build_patch_fname(idx, p):
        r = "%04d-" % idx
        try:
            msg = Message(p)
            p = msg.get_subject(strip_tags=True)
            for c in p:
                if c.isalnum() or c in "-_[]":
                    r += c
                else:
                    r += "-"
        except:
            r += "unknown"
        r += ".patch"
        return r

    os.mkdir(odir)
    idx = 1
    patch_list = []
    for p in spec['patches-mbox-list']:
        p = p.encode("utf-8", "ignore")
        fn = build_patch_fname(idx, p)
        test_log(fn, "\n")
        fn_full = os.path.join(odir, fn)
        patch_list.append(fn_full)
        f = open(fn_full, "w")
        f.write(p)
        f.close()
        idx += 1
    return patch_list

def apply_patches(gitdir, patches):
    output = tempfile.TemporaryFile()
    cmd = ["git", "am"] + patches
    ap = subprocess.Popen(cmd,
                          stderr=output,
                          stdout=output,
                          stdin=subprocess.PIPE,
                          cwd=gitdir)

    ap.communicate()
    output.seek(0)
    test_log(output.read())
    output.close()
    if ap.returncode != 0:
        test_log("\nFailed to apply patches\n")
        return False
    test_log("\nPatches applied.\n")
    return True

def docker_test(tmpdir, image):
    output = tempfile.TemporaryFile()
    tp = subprocess.Popen(["docker", "run",
                "--net=none",
                "-v", "%s:/var/tmp/patchew-test" % tmpdir,
                image,
                "/var/tmp/patchew-test/run_test", "/var/tmp/patchew-test"], stdout=output, stderr=output)
    tp.communicate()
    output.seek(0)
    test_log(output.read())
    output.close()
    step = ""
    if tp.returncode != 0:
        try:
            step_file = open(os.path.join(tmpdir, "step"), "r")
            step = step_file.read().splitlines()[-1]
            step_file.close()
        except:
            pass
        return False, step
    else:
        return True, ""

def check_merged(gitdir, msg_ids):
    cmd = ["git", "log", "--oneline"]
    for i in msg_ids:
        cmd += ["--grep", "Message-id: " + i]
    try:
        out = subprocess.check_output(cmd, cwd=gitdir)
        if len(out.splitlines()) == len(msg_ids):
            return True
    except Exception, e:
        print e
        return False
    return False

def do_test(tmpdir, spec, args):
    test_log("\n")
    test_log("=======================\n")
    test_log("Patchew testing started\n")
    test_log("=======================\n")
    test_log("\n")
    test_log("Test directory: ", tmpdir, "\n")
    if args.quick_repo:
        clone = args.quick_repo
    else:
        clone = spec['codebase']

    repo = os.path.join(tmpdir, "git")

    test_log("\n=== Initializing code base ===\n")
    init_git_repo(spec, clone, repo)

    test_log("\n=== Checking if the code is already merged ===\n")
    if check_merged(repo, spec['patches-message-id-list']):
        test_log("Yes.\n\n")
        return True, "merged"
    else:
        test_log("No...\n\n")

    test_log("\n=== Writing patches ===\n")
    patches_dir = os.path.join(tmpdir, "patches")
    patches = write_patches(spec, patches_dir)

    test_log("\n=== Applying patches ===\n")

    if not apply_patches(repo, patches):
        return False, "apply"

    test_copy = os.path.join(tmpdir, "run_test")

    test_log('\nCopying test script "%s"\n' % args.test_script)
    shutil.copy2(args.test_script, test_copy)

    test_log("\n=== Starting docker ===\n")
    passed, step = docker_test(tmpdir, args.image)
    if not passed:
        test_log("\nTest failed.\n")
        return False, step
    test_log("\n=== Test finished ===\n")
    return True, ""

def tester_cmd(args):
    global logf
    check_call(["docker", "version"])
    base_url = args.server
    if not base_url.endswith("/"):
        base_url += "/"
    next_url = base_url + "testing/next"
    report_url = base_url + "testing/report"
    while True:
        try:
            tmpdir = tempfile.mkdtemp(dir="/var/tmp")
            logfile = os.path.join(tmpdir, "log")
            if logf:
                logf.close()
            logf = open(logfile, "w+")
            test_log("Server: %s\n" % base_url)
            test_log("Fetching new test... ")
            r = urllib.urlopen(next_url)
            resp = r.read()
            r.close()
            try:
                spec = json.loads(resp)
            except Exception, e:
                test_log("Invalid response from server:\n", resp)
                raise e
            if spec['version'] != VERSION:
                test_log("Unknown server version: ", spec['version'])
                return False

            test_log("OK\n")
            if spec['has-data']:
                dump_test_spec(spec)
                result, reason = do_test(tmpdir, spec, args)
                logf.seek(0)
                postdata = urllib.urlencode({
                    'message-id': spec['message-id'],
                    'passed': result,
                    'failure-step': reason,
                    'merged': result and reason == "merged",
                    'log': logf.read(),
                    'version': VERSION,
                    })
                logf.close()
                try:
                    r = urllib.urlopen(report_url, postdata)
                    resp = r.read()
                    r.close()
                    resp = json.loads(resp)
                except Exception, e:
                    print "Could not submit test result:", e
                if not args.keep_temp:
                    shutil.rmtree(tmpdir, True)
            else:
                print "Nothing to test, let's have a rest..."
                time.sleep(60)
        except Exception, e:
            test_log(str(e))
            pass
        if not args.loop:
            break

commands = {
    'import':  {
        'args': import_args,
        'cmd': import_cmd,
    },
    'syncdb':  {
        'args': syncdb_args,
        'cmd': syncdb_cmd,
        'help': 'rescan all the messages and update metadata',
    },
    'query':  {
        'args': query_args,
        'cmd': query_cmd,
    },
    'untest':  {
        'args': untest_args,
        'cmd': untest_cmd,
        'help': 'reset testing date for series',
    },
    'server':  {
        'cmd': server_cmd,
    },
    'tester': {
        'cmd': tester_cmd,
        'require-db': False,
        'args': tester_args
    },
}

def create_db(url):
    dbt, rest = url.split("://", 2)
    if dbt != "mongo":
        raise Exception("Unknown database type: " + dbt)
    if "/" not in rest:
        raise Exception("Missing database name")
    server, dbname = rest.split("/")
    if ":" in server:
        server, port = server_port.split(":", 2)
        try:
            port = int(port)
        except Exception, e:
            raise Exception("Invalid port: " + port)
    else:
        port = None
    return DB(server, port, dbname)

def no_db_wrap(fn):
    def wrap(db, args):
        return fn(args)
    return wrap

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-d", "--db", type=str, default="mongo://localhost/patchew",
                        help="database url: <type>://<server>[:<port>]/<dbname>\nCurrently only mongo:// is supported")
    subparsers = parser.add_subparsers(title="subcommands")
    for c, v in commands.iteritems():
        p = subparsers.add_parser(c, help=v.get("help"))
        if 'args' in v:
            v['args'](p)
        if v.get('require-db', True):
            p.set_defaults(func=v['cmd'])
            p.set_defaults(require_db=True)
        else:
            p.set_defaults(func=no_db_wrap(v['cmd']))
            p.set_defaults(require_db=False)
    args = parser.parse_args()

    db = None
    if args.require_db:
        try:
            db = create_db(args.db)
        except Exception, e:
            print "Error in initializing database:", e
            return -1
    return args.func(db, args)

if __name__ == '__main__':
    sys.exit(main())

